# SCRU64: Sortable, Clock-based, Realm-specifically Unique identifier

SCRU64 ID offers compact, time-ordered unique identifiers generated by
distributed nodes. SCRU64 has the following features:

- ~62-bit non-negative integer storable as signed/unsigned 64-bit integer
- Sortable by generation time (as integer and as text)
- 12-digit case-insensitive textual representation (Base36)
- ~38-bit Unix epoch-based timestamp that ensures useful life until year 4261
- Variable-length node/machine ID and counter fields that share 24 bits

Examples in the 12-digit canonical textual representation:

```
0u375nxqh5cq
0u375nxqh5cr
0u375nxqh5cs
0u375nxqh5ct
0u375ny0glr0
0u375ny0glr1
0u375ny0glr2
0u375ny0glr3
```

SCRU64's uniqueness is realm-specific, i.e., dependent on the centralized
assignment of node ID to each generator. If you need decentralized, globally
unique time-ordered identifiers, consider [SCRU128].

[SCRU128]: https://github.com/scru128/spec

## Specification (work in progress)

A SCRU64 ID is a non-negative integer less than `36^12` (approx. `2^62`)
consisting of three terms:

```
timestamp * 2^24 + node_id * 2^(24 - node_id_size) + counter
```

Where:

- `timestamp` is a non-negative integer less than `36^12 / 2^24` representing a
  256-millisecond-precision Unix timestamp (i.e., the number of 256 milliseconds
  elapsed since 1970-01-01 00:00:00+00:00, ignoring leap seconds; or a Unix
  timestamp in milliseconds divided by 256).
- `node_id` is a `node_id_size`-bit unsigned integer uniquely assigned to each
  SCRU64 generator in the relevant scope, where `node_id_size` is an integer
  between 1 and 23, inclusive.
  - The method to assign unique `node_id`s is implementation-dependent and is
    out of the scope of this specification.
  - `node_id_size` may be chosen arbitrarily.
- `counter` is a `24 - node_id_size`-bit unsigned integer incremented by one
  whenever a generator produces a new ID. `counter` is reset to an arbitrary-bit
  random number when `timestamp` moves forward.
  - `counter` should generally be reset to a `24 - node_id_size`-bit random
    number but may be reset to a smaller-bit random number to ensure a `counter`
    can accommodate a certain number of IDs within a `timestamp` tick.

This definition is equivalent to the following binary bit-shift operations:

```
timestamp = unix_timestamp_in_milliseconds >> 8
output = (timestamp << 24) | (node_id << (24 - node_id_size)) | counter
```

### Binary representation

A SCRU64 ID is usually represented as a 64-bit signed or unsigned integer.

### Textual representation

A SCRU64 ID is encoded in a string using the _Base36_ encoding. The Base36
denotes a SCRU64 ID as an unsigned integer in the radix of 36 using the digits
of `0-9a-z` (`0123456789abcdefghijklmnopqrstuvwxyz`), with leading zeros added
to form a 12-digit canonical representation. The following pseudo equation
illustrates the encoding algorithm:

```
109959589539758421
    =  0  * 36^11 + 30  * 36^10 +  2  * 36^9 + ... +  4  * 36^2 + 11  * 36^1 +  9
    = '0' * 36^11 + 'u' * 36^10 + '2' * 36^9 + ... + '4' * 36^2 + 'b' * 36^1 + '9'
    = "0u2pf62ji4b9"
```

The maximum value (`36^12 - 1`) of SCRU64 ID is defined as the maximum value
denotable in a 12-digit Base36 string (i.e., `zzzzzzzzzzzz`).

For the sake of uniformity, an encoder should use lowercase letters in encoding
IDs. A decoder, on the other hand, must always ignore cases when interpreting or
lexicographically sorting encoded IDs.

### License

This work is licensed under a [Creative Commons Attribution 4.0 International
(CC BY 4.0) License].

[Creative Commons Attribution 4.0 International (CC BY 4.0) License]: http://creativecommons.org/licenses/by/4.0/
